import * as NanoCurrency from 'nanocurrency';
import * as blakejs from 'blakejs';

class BlockSigner {
	constructor(cryptoUtils, ec) {
		this.cryptoUtils = cryptoUtils;
		this.ec = ec;
		this.zValues = {};
	}

	GetPublicKeyFromPrivate(privateKey) {
		/**
		 * NOTE: the public key generated by the elliptic curve library is _different_ to the public key generated by
		 * the NanoCurrency library. The signing/verification algorithms are NOT identical. The elliptic curve library
		 * must be used for the aggregated-signature stuff. Here, we also use it for convenience to prove our identity
		 * when passing messages.
		 *
		 * When we want to generate a Nano address for an aggregated public key, we take the _aggregated_ public key
		 * from the elliptic curve library, covert it to a hex string, and derive a Nano address from that.
		 *
		 * When we want to generate a Nano address for a single public key, then we must take a different route. We
		 * must use NanoCurrency to generate a public key from our private key, then generate the Nano address from
		 * that public key.
		 *
		 * This has the potential to lead to confusion, since there are two different public keys for each private
		 * key. Hopefully anyone who gets them confused will hopefully stumble on this comment, and find their answer.
		 */
		let keyPair = this.ec.keyFromSecret(privateKey);
		return this.ec.decodePoint(keyPair.pubBytes());
	}

	GetNanoAddressForAggregatedPublicKey(pubKeys) {
		let aggregatedPublicKeyPoint = this.GetAggregatedPublicKey(pubKeys);
		let aggPubKey = this.ec.keyFromPublic(aggregatedPublicKeyPoint);

		let aggPubKeyHex = this.cryptoUtils.ByteArrayToHex(aggPubKey.pubBytes());
		return NanoCurrency.deriveAddress(aggPubKeyHex, {useNanoPrefix: true});
	}

	GetRCommitment(privateKey, messageToSign) {
		let playerData = this.getPlayerData(privateKey, messageToSign);
		let sigComponents = this.getSignatureComponentsForPlayer(playerData, messageToSign);

		return sigComponents['RPointCommitment'];
	}

	GetRPoint(privateKey, messageToSign) {
		let playerData = this.getPlayerData(privateKey, messageToSign);
		let sigComponents = this.getSignatureComponentsForPlayer(playerData, messageToSign);

		return sigComponents['RPoint'];
	}

	GetSignatureContribution(privateKey, messageToSign, pubKeys, RPoints) {
		let messageBytes = this.cryptoUtils.HexToByteArray(messageToSign);

		let playerData = this.getPlayerData(privateKey, messageToSign);
		let sigComponents = this.getSignatureComponentsForPlayer(playerData, messageToSign);
		let aggregatedRPoint = this.getAggregatedRPoint(RPoints);

		console.log('Signature Contribution Inputs:');
		console.log('Aggregated R Point: ' + this.cryptoUtils.ByteArrayToHex(this.ec.encodePoint(aggregatedRPoint)));
		console.log('PubKeys: ' + pubKeys.map((pubKey) => { return this.cryptoUtils.ByteArrayToHex(this.ec.encodePoint(pubKey)); }).join('\n'));
		console.log('Message: ' + messageBytes);
		console.log('PlayerData:');
		console.log('\tSecret Key: '+this.cryptoUtils.ByteArrayToHex(playerData.secretKeyBytes));
		console.log('\tPublic Key: '+this.cryptoUtils.ByteArrayToHex(playerData.publicKeyBytes));
		console.log('\tMessage Prefix: '+this.cryptoUtils.ByteArrayToHex(playerData.messagePrefix));
		console.log('\tZValue: '+playerData.zValue);
		console.log('Signature Components:');
		console.log('\trHash:' + sigComponents.rHash.toString(16));
		console.log('\tRCommitment:' + sigComponents.RPointCommitment.toString(16));
		console.log('\tRPoint:' + this.cryptoUtils.ByteArrayToHex(this.ec.encodePoint(sigComponents.RPoint).toString(16)));

		return this.getSignatureContributionInternal(aggregatedRPoint, pubKeys, messageBytes, playerData, sigComponents);
	}

	SignMessageSingle(message, privateKey) {
		if (typeof message !== 'string') {
			throw new Error("Message parameter must be a hexadecimal string.");
		}

		let nonHexadecimalRegexp = RegExp('[^ABCDEF1234567890]');
		if (nonHexadecimalRegexp.test(message)) {
			throw new Error("Message parameter must be a hexadecimal string.");
		}

		return this.ec.sign(message, privateKey);
	}

	VerifyMessageSingle(message, signature, pubKey) {
		return this.ec.verify(message, signature, pubKey);
	}

	SignMessageMultiple(signatureContributions, RPoints) {
		let aggregatedRPoint = this.getAggregatedRPoint(RPoints);

		// console.log('SignMessageMultiple Inputs:');
		// console.log('Signature Contributions:');
		// console.log(signatureContributions.map((sigcon) => {
		// 	return sigcon.toString(16);
		// }));
		// console.log('Aggregated R Point:');
		// console.log(this.cryptoUtils.ByteArrayToHex(this.ec.encodePoint(aggregatedRPoint)));

		let aggregatedSignature = null;

		for (let i = 0; i < signatureContributions.length; i++) {
			// console.log('Signature Contribution '+i+': '+signatureContributions[i].toString(16));
			if (aggregatedSignature === null) {
				aggregatedSignature = signatureContributions[i];
				// console.log("Aggregate sig progress:" + aggregatedSignature);
			} else {
				aggregatedSignature = aggregatedSignature.add(signatureContributions[i]); // bigint addition
				// console.log("Aggregate sig progress:" + aggregatedSignature);
			}
		}

		let sigStruct = this.ec.makeSignature({
			R: aggregatedRPoint,
			S: aggregatedSignature,
			Rencoded: this.ec.encodePoint(aggregatedRPoint),
			Sencoded: this.ec.encodeInt(aggregatedSignature)
		});

		return sigStruct.toHex();
	}

	GetAggregatedPublicKey(pubKeys) {
		// console.log('Generating aggregated public key point.');
		// pubKeys.sort(this.sortPointsByHexRepresentation.bind(this));

		let aggregatedPublicKeyPoint = null;
		let aHashComponent = null;
		let aggregationComponentPoint = null;

		for (let i = 0; i < pubKeys.length; i++) {
			aHashComponent = this.getAHashSignatureComponent(pubKeys[i], pubKeys);
			aggregationComponentPoint = pubKeys[i].mul(aHashComponent);
			// console.log('AHash: ' + aHashComponent);

			if (aggregatedPublicKeyPoint === null) {
				aggregatedPublicKeyPoint = aggregationComponentPoint;
			} else {
				aggregatedPublicKeyPoint = aggregatedPublicKeyPoint.add(aggregationComponentPoint); // point addition
			}
		}

		// console.log(this.cryptoUtils.ByteArrayToHex(this.ec.encodePoint(aggregatedPublicKeyPoint)));
		return aggregatedPublicKeyPoint;
	}

	SortPointsByHexRepresentation(point1, point2) {
		let point1Hex = this.cryptoUtils.ByteArrayToHex(this.ec.encodePoint(point1));
		let point2Hex = this.cryptoUtils.ByteArrayToHex(this.ec.encodePoint(point2));

		return point1Hex.localeCompare(point2Hex);
	}

	getAHashSignatureComponent(playerPublicKeyPoint, pubKeys) {
		let hashArguments = [this.ec.encodePoint(playerPublicKeyPoint)];
		// console.log('Hash Arguments: ' + hashArguments);

		for (let i = 0; i < pubKeys.length; i++) {
			hashArguments.push(this.ec.encodePoint(pubKeys[i]));
			// console.log('Hash Arguments ('+i+'): ' + hashArguments);
		}

		return this.ec.hashInt.apply(this.ec, hashArguments);
	}

	getPlayerData(secret, messageToSign) {
		let key = this.ec.keyFromSecret(secret); // hex string, array or Buffer

		return {
			'secretKeyBytes': key.privBytes(),
			'publicKeyBytes': key.pubBytes(),
			'publicKeyPoint': this.ec.decodePoint(key.pubBytes()),
			'messagePrefix': key.messagePrefix(),
			// 'zValue': this.getZValue(secret, messageToSign)
			'zValue': this.getZValueDeterministic(secret)
		};
	}

	getZValueDeterministic(secret) {
		let zValue =  this.cryptoUtils.ByteArrayToHex(blakejs.blake2b(this.cryptoUtils.HexToByteArray(secret)));
		return this.cryptoUtils.HexToByteArray(zValue);
	}

	getZValue(secret, messageToSign) {
		if (!this.zValues[secret][messageToSign]) {
			if (!this.zValues[secret]) {
				this.zValues[secret] = {};
			}

			this.zValues[secret][messageToSign] = this.getRandomBytes(32);
		}

		return this.zValues[secret][messageToSign];
	}

	getRandomBytes(length) {
		let result = [];
		for (let i = 0; i < length; i++) {
			result.push(Math.floor(Math.random() * 256));
		}

		return result;
	}

	getSignatureComponentsForPlayer(playerData, message) {
		message = this.cryptoUtils.HexToByteArray(message);

		console.log('Signature components inputs:');
		console.log('PlayerData.MessagePrefix: '+this.cryptoUtils.ByteArrayToHex(playerData.messagePrefix));
		console.log('PlayerData.zValue: '+this.cryptoUtils.ByteArrayToHex(playerData.zValue));
		console.log('Message: '+message);

		let r = this.ec.hashInt(playerData.messagePrefix, message, playerData.zValue);
		let R = this.ec.g.mul(r);
		let Rencoded = this.ec.encodePoint(R);
		let t = this.ec.hashInt(Rencoded);

		return {
			'rHash': r,
			'RPoint': R,
			'RPointCommitment': t
		};
	}

	getAggregatedRPoint(RPoints) {
		// console.log('Aggregated R Point Inputs:');
		// console.log(RPoints.map((RPoint) => {
		// 	return this.cryptoUtils.ByteArrayToHex(this.ec.encodePoint(RPoint));
		// }));

		// RPoints.sort(this.sortPointsByHexRepresentation.bind(this));
		let aggregatedRPoint = null;

		for (let i = 0; i < RPoints.length; i++) {
			if (aggregatedRPoint === null) {
				aggregatedRPoint = RPoints[i];
			} else {
				aggregatedRPoint = aggregatedRPoint.add(RPoints[i]); // point addition
			}
		}

		return aggregatedRPoint;
	}

	getKHash(aggregatedRPoint, aggregatedPublicKeyPoint, message) {
		return this.ec.hashInt(this.ec.encodePoint(aggregatedRPoint), this.ec.encodePoint(aggregatedPublicKeyPoint), message);
	}

	getSignatureContributionInternal(aggregatedRPoint, pubKeys, message, playerData, signatureComponents) {
		let aggregatedPublicKeyPoint = this.GetAggregatedPublicKey(pubKeys);
		let aHashSignatureComponent = this.getAHashSignatureComponent(playerData['publicKeyPoint'], pubKeys);
		let kHash = this.getKHash(aggregatedRPoint, aggregatedPublicKeyPoint, message);

		let signatureContribution = kHash.mul(this.ec.decodeInt(playerData['secretKeyBytes']));
		signatureContribution = signatureContribution.mul(aHashSignatureComponent); // not absolutely certain about the order of operations here.
		signatureContribution = signatureComponents['rHash'].add(signatureContribution); // bigint addition
		signatureContribution = signatureContribution.umod(this.ec.curve.n); // appears to not be needed? Rust implementation doesn't seem to have it, even for single sig.

		return signatureContribution;
	}

}

export default BlockSigner;
